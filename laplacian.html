<!DOCTYPE html><html lang="en"><head><meta charset="utf-8" /><title>Matting Laplacians â€” PyMatting 1.1.10 documentation</title><link rel="stylesheet" href="/katex.min.css"><link rel="stylesheet" href="/style.css"><script src="/katex.min.js"></script></head><body><div class="sidebar"><div class="logo"><a href="/" class="sidebarlink"><img src="/figures/lemur_small.png" width="50px"></a><a href="/" class="logotext">PyMatting</a></div><div class="sidebarcontents">CONTENTS</div><ul><li><a href="/index.html" class="sidebarlink">PyMatting</a></li><li class="sidebarlink"><a href="/api.html" class="sidebarlink">API Reference</a><br><ul><li><a href="/alpha.html" class="sidebarlink">Alpha Estimation</a></li><li><a href="/cutout.html" class="sidebarlink">Cutout Function</a></li><li><a href="/foreground.html" class="sidebarlink">Foreground Estimation</a></li><li><a href="/laplacian.html" class="sidebarlink currentpage">Matting Laplacians</a></li><li><a href="/preconditioner.html" class="sidebarlink">Preconditioners</a></li><li><a href="/solver.html" class="sidebarlink">Solvers</a></li><li><a href="/util.html" class="sidebarlink">Utility Functions</a></li></ul></li><li><a href="/examples.html" class="sidebarlink">Examples</a></li><li><a href="/benchmarks.html" class="sidebarlink">Benchmarks</a></li><li><a href="/references.html" class="sidebarlink">Biblography</a></li><li><a href="https://pypi.org/project/PyMatting/" class="sidebarlink">PyPI</a></li><li><a href="https://www.github.com/pymatting/pymatting" class="sidebarlink">GitHub</a></li></ul></div><div class="middle"><h1>Matting Laplacians</h1><div><div class="function"><div id="cf_laplacian"><a href="https://github.com/pymatting/pymatting/blob/master/pymatting/laplacian/cf_laplacian.py#L132-L177"><img src="/figures/github-mark.svg" title="Function definition on GitHub" class="github-icon"></a><h3 class="functionname">pymatting.cf_laplacian</h3><a href="#cf_laplacian" title="Permalink to this definition" class="functionanchorlink"> ðŸ”—</a></div><div class="signature"><h4>Signature</h4><div class="signature"><div class="codeblock"><span class=name>cf_laplacian</span><span class=operator>(</span><span class=space>
    </span><span class=name>image</span><span class=operator>,</span><span class=space>
    </span><span class=name>epsilon</span><span class=operator>=</span><span class=number>1e-7</span><span class=operator>,</span><span class=space>
    </span><span class=name>radius</span><span class=operator>=</span><span class=number>1</span><span class=operator>,</span><span class=space>
    </span><span class=name>is_known</span><span class=operator>=</span><span class=keyword>None</span><span class=operator>)</span></div></div></div><h4>Function Description</h4><div class="textblock"><span class="text">This function implements the alpha estimator for closed-form alpha matting
as proposed by </span><span class="citation"><a href="/references.html#LLW07">[LLW07]</a></span><span class="text">.</span></div><h4>Parameters</h4><ul><li class="parameteritem"><span class="parameter">image</span> (<i>numpy.ndarray</i>)<ul><div class="parameterdescription"><span class="text">Image with shape </span><span class="inline_math">\(h\times w \times 3\)</span></div></ul></li><li class="parameteritem"><span class="parameter">epsilon</span> (<i>float</i>)<ul><div class="parameterdescription"><span class="text">Regularization strength, defaults to </span><span class="inline_math">\(10^{-7}\)</span><span class="text">. Strong</span><span class="text"> </span><span class="text">regularization improves convergence but results in smoother alpha mattes.</span></div></ul></li><li class="parameteritem"><span class="parameter">radius</span> (<i>int</i>)<ul><div class="parameterdescription"><span class="text">Radius of local window size, defaults to </span><span class="inline_math">\(1\)</span><span class="text">, i.e. only adjacent</span><span class="text"> </span><span class="text">pixels are considered. </span><span class="text">The size of the local window is given as </span><span class="inline_math">\((2 r + 1)^2\)</span><span class="text">, where</span><span class="text"> </span><span class="inline_math">\(r\)</span><span class="text"> denotes         the radius. A larger radius might lead to</span><span class="text"> </span><span class="text">violated color line constraints, but also </span><span class="text">favors further propagation of information within the image.</span></div></ul></li><li class="parameteritem"><span class="parameter">is_known</span> (<i>numpy.ndarray</i>)<ul><div class="parameterdescription"><span class="text">Binary mask of pixels for which to compute the laplacian matrix. </span><span class="text">Laplacian entries for known pixels will have undefined values.</span></div></ul></li></ul><h4>Returns</h4><ul><li class="parameteritem"><span class="parameter">L</span> (<i>scipy.sparse.spmatrix</i>)<ul><div class="parameterdescription"><span class="text">Matting Laplacian</span></div></ul></li></ul></div></div><div><div class="function"><div id="knn_laplacian"><a href="https://github.com/pymatting/pymatting/blob/master/pymatting/laplacian/knn_laplacian.py#L7-L92"><img src="/figures/github-mark.svg" title="Function definition on GitHub" class="github-icon"></a><h3 class="functionname">pymatting.knn_laplacian</h3><a href="#knn_laplacian" title="Permalink to this definition" class="functionanchorlink"> ðŸ”—</a></div><div class="signature"><h4>Signature</h4><div class="signature"><div class="codeblock"><span class=name>knn_laplacian</span><span class=operator>(</span><span class=space>
    </span><span class=name>image</span><span class=operator>,</span><span class=space>
    </span><span class=name>n_neighbors</span><span class=operator>=</span><span class=operator>[</span><span class=number>20</span><span class=operator>,</span><span class=space> </span><span class=number>10</span><span class=operator>]</span><span class=operator>,</span><span class=space>
    </span><span class=name>distance_weights</span><span class=operator>=</span><span class=operator>[</span><span class=number>2.0</span><span class=operator>,</span><span class=space> </span><span class=number>0.1</span><span class=operator>]</span><span class=operator>,</span><span class=space>
    </span><span class=name>kernel</span><span class=operator>=</span><span class=string>&quot;binary&quot;</span><span class=operator>)</span></div></div></div><h4>Function Description</h4><div class="textblock"><span class="text">This function calculates the KNN matting Laplacian matrix similar to
</span><span class="citation"><a href="/references.html#CLT13">[CLT13]</a></span><span class="text">.
We use a kernel of 1 instead of a soft kernel by default since the former is
faster to compute and both produce almost identical results in all our
experiments, which is to be expected as the soft kernel is very close to 1
in most cases.</span></div><h4>Parameters</h4><ul><li class="parameteritem"><span class="parameter">image</span> (<i>numpy.ndarray</i>)<ul><div class="parameterdescription"><span class="text">Image with shape </span><span class="inline_math">\(h\times w \times 3\)</span></div></ul></li><li class="parameteritem"><span class="parameter">n_neighbors</span> (<i>list of ints</i>)<ul><div class="parameterdescription"><span class="text">Number of neighbors to consider. If </span><span class="inline_code"><span class="codeinline"><span class=keyword>len</span><span class=operator>(</span><span class=name>n_neighbors</span><span class=operator>)</span><span class=operator>&gt;</span><span class=number>1</span></span></span><span class="text"> multiple</span><span class="text"> </span><span class="text">nearest neighbor calculations are done and merged, defaults to </span><span class="inline_code"><span class="codeinline"><span class=operator>[</span><span class=number>20</span><span class=operator>,</span><span class=space> </span><span class=number>10</span><span class=operator>]</span></span></span><span class="text">, i.e. first 20 neighbors are considered and in the second run</span><span class="text"> </span><span class="inline_math">\(10\)</span><span class="text"> neighbors. The pixel distances are then weighted by the</span><span class="text"> </span><span class="inline_code"><span class="codeinline"><span class=name>distance_weights</span></span></span><span class="text">.</span></div></ul></li><li class="parameteritem"><span class="parameter">distance_weights</span> (<i>list of floats</i>)<ul><div class="parameterdescription"><span class="text">Weight of distance in feature vector, defaults to </span><span class="inline_code"><span class="codeinline"><span class=operator>[</span><span class=number>2.0</span><span class=operator>,</span><span class=space> </span><span class=number>0.1</span><span class=operator>]</span></span></span><span class="text">.</span></div></ul></li><li class="parameteritem"><span class="parameter">kernel</span> (<i>str</i>)<ul><div class="parameterdescription"><span class="text">Must be either &quot;binary&quot; or &quot;soft&quot;. Default is &quot;binary&quot;.</span></div></ul></li></ul><h4>Returns</h4><ul><li class="parameteritem"><span class="parameter">L</span> (<i>scipy.sparse.spmatrix</i>)<ul><div class="parameterdescription"><span class="text">Matting Laplacian matrix</span></div></ul></li></ul></div></div><div><div class="function"><div id="make_linear_system"><a href="https://github.com/pymatting/pymatting/blob/master/pymatting/laplacian/laplacian.py#L5-L60"><img src="/figures/github-mark.svg" title="Function definition on GitHub" class="github-icon"></a><h3 class="functionname">pymatting.make_linear_system</h3><a href="#make_linear_system" title="Permalink to this definition" class="functionanchorlink"> ðŸ”—</a></div><div class="signature"><h4>Signature</h4><div class="signature"><div class="codeblock"><span class=name>make_linear_system</span><span class=operator>(</span><span class=space>
    </span><span class=name>L</span><span class=operator>,</span><span class=space>
    </span><span class=name>trimap</span><span class=operator>,</span><span class=space>
    </span><span class=name>lambda_value</span><span class=operator>=</span><span class=number>100.0</span><span class=operator>,</span><span class=space>
    </span><span class=name>return_c</span><span class=operator>=</span><span class=keyword>False</span><span class=operator>)</span></div></div></div><h4>Function Description</h4><div class="textblock"><span class="text">This function constructs a linear system from a matting Laplacian by
constraining the foreground and background pixels with a diagonal matrix
</span><span class="inline_code"><span class="codeinline"><span class=name>C</span></span></span><span class="text"> to values in the right-hand-side vector </span><span class="inline_code"><span class="codeinline"><span class=name>b</span></span></span><span class="text">. The constraints are
weighted by a factor </span><span class="inline_math">\(\lambda\)</span><span class="text">. The linear system is given as</span></div><div class="math_block">$$  A = L + \lambda C,
$$</div><div class="textblock"><span class="text">where </span><span class="inline_math">\(C=\mathop{Diag}(c)\)</span><span class="text"> having </span><span class="inline_math">\(c_i = 1\)</span><span class="text"> if pixel i is known
and </span><span class="inline_math">\(c_i = 0\)</span><span class="text"> otherwise.
The right-hand-side </span><span class="inline_math">\(b\)</span><span class="text"> is a vector with entries </span><span class="inline_math">\(b_i = 1\)</span><span class="text"> is
pixel is is a foreground pixel and </span><span class="inline_math">\(b_i = 0\)</span><span class="text"> otherwise.</span></div><h4>Parameters</h4><ul><li class="parameteritem"><span class="parameter">L</span> (<i>scipy.sparse.spmatrix</i>)<ul><div class="parameterdescription"><span class="text">Laplacian matrix, e.g. calculated with </span><span class="inline_code"><span class="codeinline"><span class=name>lbdm_laplacian</span></span></span><span class="text"> function</span></div></ul></li><li class="parameteritem"><span class="parameter">trimap</span> (<i>numpy.ndarray</i>)<ul><div class="parameterdescription"><span class="text">Trimap with shape </span><span class="inline_math">\(h\times w\)</span></div></ul></li><li class="parameteritem"><span class="parameter">lambda_value</span> (<i>float</i>)<ul><div class="parameterdescription"><span class="text">Constraint penalty, defaults to 100</span></div></ul></li><li class="parameteritem"><span class="parameter">return_c</span> (<i>bool</i>)<ul><div class="parameterdescription"><span class="text">Whether to return the constraint matrix </span><span class="inline_code"><span class="codeinline"><span class=name>C</span></span></span><span class="text">, defaults to False</span></div></ul></li></ul><h4>Returns</h4><ul><li class="parameteritem"><span class="parameter">A</span> (<i>scipy.sparse.spmatrix</i>)<ul><div class="parameterdescription"><span class="text">Matrix describing the system of linear equations</span></div></ul></li><li class="parameteritem"><span class="parameter">b</span> (<i>numpy.ndarray</i>)<ul><div class="parameterdescription"><span class="text">Vector describing the right-hand side of the system</span></div></ul></li><li class="parameteritem"><span class="parameter">C</span> (<i>numpy.ndarray</i>)<ul><div class="parameterdescription"><span class="text">Vector describing the diagonal entries of the matrix </span><span class="inline_code"><span class="codeinline"><span class=name>C</span></span></span><span class="text">, only returned</span><span class="text"> </span><span class="text">if </span><span class="inline_code"><span class="codeinline"><span class=name>return_c</span></span></span><span class="text"> is set to True</span></div></ul></li></ul></div></div><div><div class="function"><div id="lbdm_laplacian"><a href="https://github.com/pymatting/pymatting/blob/master/pymatting/laplacian/lbdm_laplacian.py#L64-L94"><img src="/figures/github-mark.svg" title="Function definition on GitHub" class="github-icon"></a><h3 class="functionname">pymatting.lbdm_laplacian</h3><a href="#lbdm_laplacian" title="Permalink to this definition" class="functionanchorlink"> ðŸ”—</a></div><div class="signature"><h4>Signature</h4><div class="signature"><div class="codeblock"><span class=name>lbdm_laplacian</span><span class=operator>(</span><span class=name>image</span><span class=operator>,</span><span class=space> </span><span class=name>epsilon</span><span class=operator>=</span><span class=number>1e-7</span><span class=operator>,</span><span class=space> </span><span class=name>radius</span><span class=operator>=</span><span class=number>1</span><span class=operator>)</span></div></div></div><h4>Function Description</h4><div class="textblock"><span class="text">Calculate a Laplacian matrix based on </span><span class="citation"><a href="/references.html#ZK09">[ZK09]</a></span><span class="text">.</span></div><h4>Parameters</h4><ul><li class="parameteritem"><span class="parameter">image</span> (<i>numpy.ndarray</i>)<ul><div class="parameterdescription"><span class="text">Image with shape </span><span class="inline_math">\(h\times w \times 3\)</span></div></ul></li><li class="parameteritem"><span class="parameter">epsilon</span> (<i>float</i>)<ul><div class="parameterdescription"><span class="text">Regularization strength, defaults to </span><span class="inline_math">\(10^{-7}\)</span><span class="text">. Strong</span><span class="text"> </span><span class="text">regularization improves convergence but results in smoother alpha mattes.</span></div></ul></li><li class="parameteritem"><span class="parameter">radius</span> (<i>int</i>)<ul><div class="parameterdescription"><span class="text">Radius of local window size, defaults to </span><span class="inline_math">\(1\)</span><span class="text">, i.e. only adjacent</span><span class="text"> </span><span class="text">pixels are considered. The size of the local window is given as </span><span class="inline_math">\((2 r + 1)^2\)</span><span class="text">, where </span><span class="inline_math">\(r\)</span><span class="text"> denotes the radius. A larger radius</span><span class="text"> </span><span class="text">might lead to violated color line constraints, but also favors further </span><span class="text">propagation of information within the image.</span></div></ul></li></ul><h4>Returns</h4><ul><li class="parameteritem"><span class="parameter">L</span> (<i>scipy.sparse.csr_matrix</i>)<ul><div class="parameterdescription"><span class="text">Matting Laplacian</span></div></ul></li></ul></div></div><div><div class="function"><div id="lkm_laplacian"><a href="https://github.com/pymatting/pymatting/blob/master/pymatting/laplacian/lkm_laplacian.py#L6-L76"><img src="/figures/github-mark.svg" title="Function definition on GitHub" class="github-icon"></a><h3 class="functionname">pymatting.lkm_laplacian</h3><a href="#lkm_laplacian" title="Permalink to this definition" class="functionanchorlink"> ðŸ”—</a></div><div class="signature"><h4>Signature</h4><div class="signature"><div class="codeblock"><span class=name>lkm_laplacian</span><span class=operator>(</span><span class=space>
    </span><span class=name>image</span><span class=operator>,</span><span class=space>
    </span><span class=name>epsilon</span><span class=operator>=</span><span class=number>1e-7</span><span class=operator>,</span><span class=space>
    </span><span class=name>radius</span><span class=operator>=</span><span class=number>10</span><span class=operator>,</span><span class=space>
    </span><span class=name>return_diagonal</span><span class=operator>=</span><span class=keyword>True</span><span class=operator>)</span></div></div></div><h4>Function Description</h4><div class="textblock"><span class="text">Calculates the Laplacian for large kernel matting </span><span class="citation"><a href="/references.html#HST10">[HST10]</a></span></div><h4>Parameters</h4><ul><li class="parameteritem"><span class="parameter">image</span> (<i>numpy.ndarray</i>)<ul><div class="parameterdescription"><span class="text">Image of shape </span><span class="inline_math">\(h\times w \times 3\)</span></div></ul></li><li class="parameteritem"><span class="parameter">epsilons</span> (<i>float</i>)<ul><div class="parameterdescription"><span class="text">Regularization strength, defaults to </span><span class="inline_math">\(10^{-7}\)</span></div></ul></li><li class="parameteritem"><span class="parameter">radius</span> (<i>int</i>)<ul><div class="parameterdescription"><span class="text">Radius of local window size, defaults to </span><span class="inline_math">\(10\)</span><span class="text">, i.e. only adjacent</span><span class="text"> </span><span class="text">pixels are considered. The size of the local window is given as </span><span class="inline_math">\((2 r + 1)^2\)</span><span class="text">, where </span><span class="inline_math">\(r\)</span><span class="text"> denotes the radius. A larger radius</span><span class="text"> </span><span class="text">might lead to violated color line constraints, but also favors further </span><span class="text">propagation of information within the image.</span></div></ul></li><li class="parameteritem"><span class="parameter">return_diagonal</span> (<i>bool</i>)<ul><div class="parameterdescription"><span class="text">Whether to also return the diagonal of the laplacian, defaults to True</span></div></ul></li></ul><h4>Returns</h4><ul><li class="parameteritem"><span class="parameter">L_matvec</span> (<i>function</i>)<ul><div class="parameterdescription"><span class="text">Function that applies the Laplacian matrix to a vector</span></div></ul></li><li class="parameteritem"><span class="parameter">diag_L</span> (<i>numpy.ndarray</i>)<ul><div class="parameterdescription"><span class="text">Diagonal entries of the matting Laplacian, only returns if </span><span class="inline_code"><span class="codeinline"><span class=name>return_diagonal</span></span></span><span class="text"> is True</span></div></ul></li></ul></div></div><div><div class="function"><div id="rw_laplacian"><a href="https://github.com/pymatting/pymatting/blob/master/pymatting/laplacian/rw_laplacian.py#L47-L81"><img src="/figures/github-mark.svg" title="Function definition on GitHub" class="github-icon"></a><h3 class="functionname">pymatting.rw_laplacian</h3><a href="#rw_laplacian" title="Permalink to this definition" class="functionanchorlink"> ðŸ”—</a></div><div class="signature"><h4>Signature</h4><div class="signature"><div class="codeblock"><span class=name>rw_laplacian</span><span class=operator>(</span><span class=space>
    </span><span class=name>image</span><span class=operator>,</span><span class=space>
    </span><span class=name>sigma</span><span class=operator>=</span><span class=number>0.033</span><span class=operator>,</span><span class=space>
    </span><span class=name>radius</span><span class=operator>=</span><span class=number>1</span><span class=operator>,</span><span class=space>
    </span><span class=name>regularization</span><span class=operator>=</span><span class=number>1e-8</span><span class=operator>)</span></div></div></div><h4>Function Description</h4><div class="textblock"><span class="text">This function implements the alpha estimator for random walk alpha matting
as described in </span><span class="citation"><a href="/references.html#GSAW05">[GSAW05]</a></span><span class="text">.</span></div><h4>Parameters</h4><ul><li class="parameteritem"><span class="parameter">image</span> (<i>numpy.ndarray</i>)<ul><div class="parameterdescription"><span class="text">Image with shape </span><span class="inline_math">\(h\times w \times 3\)</span></div></ul></li><li class="parameteritem"><span class="parameter">sigma</span> (<i>float</i>)<ul><div class="parameterdescription"><span class="text">Sigma used to calculate the weights (see Equation 4 in </span><span class="citation"><a href="/references.html#GSAW05">[GSAW05]</a></span><span class="text">), defaults to </span><span class="inline_math">\(0.033\)</span></div></ul></li><li class="parameteritem"><span class="parameter">radius</span> (<i>int</i>)<ul><div class="parameterdescription"><span class="text">Radius of local window size, defaults to </span><span class="inline_math">\(1\)</span><span class="text">, i.e. only adjacent</span><span class="text"> </span><span class="text">pixels are considered. The size of the local window is given as </span><span class="inline_math">\((2 r + 1)^2\)</span><span class="text">, where </span><span class="inline_math">\(r\)</span><span class="text"> denotes the radius. A larger radius</span><span class="text"> </span><span class="text">might lead to violated color line constraints, but also favors further </span><span class="text">propagation of information within the image.</span></div></ul></li><li class="parameteritem"><span class="parameter">regularization</span> (<i>float</i>)<ul><div class="parameterdescription"><span class="text">Regularization strength, defaults to </span><span class="inline_math">\(10^{-8}\)</span><span class="text">. Strong</span><span class="text"> </span><span class="text">regularization improves convergence but results in smoother alpha matte.</span></div></ul></li></ul><h4>Returns</h4><ul><li class="parameteritem"><span class="parameter">L</span> (<i>scipy.sparse.spmatrix</i>)<ul><div class="parameterdescription"><span class="text">Matting Laplacian</span></div></ul></li></ul></div></div><div><div class="function"><div id="uniform_laplacian"><a href="https://github.com/pymatting/pymatting/blob/master/pymatting/laplacian/uniform_laplacian.py#L9-L31"><img src="/figures/github-mark.svg" title="Function definition on GitHub" class="github-icon"></a><h3 class="functionname">pymatting.uniform_laplacian</h3><a href="#uniform_laplacian" title="Permalink to this definition" class="functionanchorlink"> ðŸ”—</a></div><div class="signature"><h4>Signature</h4><div class="signature"><div class="codeblock"><span class=name>uniform_laplacian</span><span class=operator>(</span><span class=name>image</span><span class=operator>,</span><span class=space> </span><span class=name>radius</span><span class=operator>=</span><span class=number>1</span><span class=operator>)</span></div></div></div><h4>Function Description</h4><div class="textblock"><span class="text">This function returns a Laplacian matrix with all weights equal to one.</span></div><h4>Parameters</h4><ul><li class="parameteritem"><span class="parameter">image</span> (<i>numpy.ndarray</i>)<ul><div class="parameterdescription"><span class="text">Image with shape </span><span class="inline_math">\(h\times w \times 3\)</span></div></ul></li><li class="parameteritem"><span class="parameter">radius</span> (<i>int</i>)<ul><div class="parameterdescription"><span class="text">Radius of local window size, defaults to 1, i.e. only adjacent pixels are considered. </span><span class="text">The size of the local window is given as </span><span class="inline_math">\((2 r + 1)^2\)</span><span class="text">, where </span><span class="inline_math">\(r\)</span><span class="text"> denotes         the radius. A larger radius might lead to violated color line constraints, but also</span><span class="text"> </span><span class="text">favors further propagation of information within the image.</span></div></ul></li></ul><h4>Returns</h4><ul><li class="parameteritem"><span class="parameter">L</span> (<i>scipy.sparse.spmatrix</i>)<ul><div class="parameterdescription"><span class="text">Matting Laplacian</span></div></ul></li></ul></div></div><footer>Â© Copyright 2023, Thomas Germer, Tobias Uelwer, Stefan Conrad, Stefan Harmeling</footer></div><script src="/auto-render.min.js" onload="renderMathInElement(document.body)"></script></body></html>